/**\n * Performance Profiler - React 18 Profiler with enhanced metrics\n * Features: Concurrent rendering metrics, performance tracking, optimization recommendations\n */\n\nimport React, { Profiler, useCallback, useEffect, useRef, useState } from 'react'\nimport { usePerformanceActions, useAppActions } from '../../store'\n\n// Performance profiler component\nexport const PerformanceProfiler = ({ id, children, onRender, disabled = false }) => {\n  const { updatePerformanceMetrics, recordTiming } = usePerformanceActions()\n  const { addNotification } = useAppActions()\n  \n  const renderCountRef = useRef(0)\n  const slowRendersRef = useRef(0)\n  const [isOptimizationNeeded, setIsOptimizationNeeded] = useState(false)\n  \n  // Enhanced profiler callback\n  const handleProfilerRender = useCallback((id, phase, actualDuration, baseDuration, startTime, commitTime) => {\n    renderCountRef.current++\n    \n    // Record performance metrics\n    const performanceData = {\n      componentId: id,\n      phase, // 'mount' or 'update'\n      actualDuration,\n      baseDuration,\n      startTime,\n      commitTime,\n      renderCount: renderCountRef.current,\n      timestamp: Date.now()\n    }\n    \n    // Track slow renders\n    if (actualDuration > 16) { // More than one frame at 60fps\n      slowRendersRef.current++\n      \n      if (actualDuration > 100) { // Very slow render\n        addNotification({\n          type: 'warning',\n          title: 'Slow Render Detected',\n          message: `Component \"${id}\" took ${actualDuration.toFixed(2)}ms to render`,\n          duration: 3000\n        })\n      }\n    }\n    \n    // Record timing for analysis\n    recordTiming(id, actualDuration, {\n      phase,\n      baseDuration,\n      commitTime: commitTime - startTime\n    })\n    \n    // Check for optimization opportunities\n    const slowRenderPercentage = (slowRendersRef.current / renderCountRef.current) * 100\n    if (slowRenderPercentage > 20 && renderCountRef.current > 10) {\n      if (!isOptimizationNeeded) {\n        setIsOptimizationNeeded(true)\n        addNotification({\n          type: 'info',\n          title: 'Optimization Opportunity',\n          message: `Component \"${id}\" has ${slowRenderPercentage.toFixed(1)}% slow renders. Consider optimization.`,\n          duration: 5000\n        })\n      }\n    }\n    \n    // Call custom onRender if provided\n    if (onRender) {\n      onRender(performanceData)\n    }\n    \n    // Development logging\n    if (process.env.NODE_ENV === 'development' && actualDuration > 50) {\n      console.group(`🐌 Slow Render: ${id}`)\n      console.log('Phase:', phase)\n      console.log('Actual Duration:', `${actualDuration.toFixed(2)}ms`)\n      console.log('Base Duration:', `${baseDuration.toFixed(2)}ms`)\n      console.log('Render Count:', renderCountRef.current)\n      console.log('Slow Render %:', `${slowRenderPercentage.toFixed(1)}%`)\n      console.groupEnd()\n    }\n  }, [recordTiming, addNotification, onRender, isOptimizationNeeded])\n  \n  // Reset optimization flag when component unmounts or id changes\n  useEffect(() => {\n    return () => {\n      renderCountRef.current = 0\n      slowRendersRef.current = 0\n      setIsOptimizationNeeded(false)\n    }\n  }, [id])\n  \n  // Skip profiling if disabled or in production (unless explicitly enabled)\n  if (disabled || (process.env.NODE_ENV === 'production' && !window.__ENABLE_PROFILING__)) {\n    return children\n  }\n  \n  return (\n    <Profiler id={id} onRender={handleProfilerRender}>\n      {children}\n    </Profiler>\n  )\n}\n\n// Hook for manual performance measurements\nexport const usePerformanceMeasurement = (name) => {\n  const { recordTiming } = usePerformanceActions()\n  const startTimeRef = useRef(null)\n  \n  const startMeasurement = useCallback(() => {\n    startTimeRef.current = performance.now()\n  }, [])\n  \n  const endMeasurement = useCallback((metadata = {}) => {\n    if (startTimeRef.current !== null) {\n      const duration = performance.now() - startTimeRef.current\n      recordTiming(name, duration, metadata)\n      startTimeRef.current = null\n      return duration\n    }\n    return null\n  }, [name, recordTiming])\n  \n  const measureAsync = useCallback(async (asyncFn) => {\n    startMeasurement()\n    try {\n      const result = await asyncFn()\n      const duration = endMeasurement({ success: true })\n      return { result, duration }\n    } catch (error) {\n      const duration = endMeasurement({ success: false, error: error.message })\n      throw { error, duration }\n    }\n  }, [startMeasurement, endMeasurement])\n  \n  return {\n    startMeasurement,\n    endMeasurement,\n    measureAsync\n  }\n}\n\n// Component for measuring render performance of specific elements\nexport const RenderMeasurer = ({ name, children, threshold = 16 }) => {\n  const { recordTiming } = usePerformanceActions()\n  const { addNotification } = useAppActions()\n  const renderStartRef = useRef(null)\n  \n  useEffect(() => {\n    renderStartRef.current = performance.now()\n  })\n  \n  useEffect(() => {\n    if (renderStartRef.current !== null) {\n      const renderDuration = performance.now() - renderStartRef.current\n      \n      recordTiming(`render-${name}`, renderDuration)\n      \n      if (renderDuration > threshold) {\n        addNotification({\n          type: 'warning',\n          title: 'Slow Render',\n          message: `\"${name}\" took ${renderDuration.toFixed(2)}ms to render`,\n          duration: 2000\n        })\n      }\n      \n      renderStartRef.current = null\n    }\n  })\n  \n  return children\n}\n\n// HOC for automatic performance profiling\nexport const withPerformanceProfiler = (WrappedComponent, profileId) => {\n  const WithProfilerComponent = (props) => {\n    const id = profileId || WrappedComponent.displayName || WrappedComponent.name || 'Unknown'\n    \n    return (\n      <PerformanceProfiler id={id}>\n        <WrappedComponent {...props} />\n      </PerformanceProfiler>\n    )\n  }\n  \n  WithProfilerComponent.displayName = `withPerformanceProfiler(${WrappedComponent.displayName || WrappedComponent.name})`\n  \n  return WithProfilerComponent\n}\n\n// Performance observer for Web APIs\nexport const usePerformanceObserver = (entryTypes = ['measure', 'navigation', 'paint']) => {\n  const { updatePerformanceMetrics } = usePerformanceActions()\n  \n  useEffect(() => {\n    if (!('PerformanceObserver' in window)) {\n      console.warn('PerformanceObserver not supported')\n      return\n    }\n    \n    const observer = new PerformanceObserver((list) => {\n      const entries = list.getEntries()\n      \n      entries.forEach((entry) => {\n        switch (entry.entryType) {\n          case 'measure':\n            updatePerformanceMetrics({\n              [`measure_${entry.name}`]: entry.duration\n            })\n            break\n          case 'navigation':\n            updatePerformanceMetrics({\n              domContentLoaded: entry.domContentLoadedEventEnd - entry.domContentLoadedEventStart,\n              loadComplete: entry.loadEventEnd - entry.loadEventStart,\n              ttfb: entry.responseStart - entry.requestStart\n            })\n            break\n          case 'paint':\n            if (entry.name === 'first-contentful-paint') {\n              updatePerformanceMetrics({ fcp: entry.startTime })\n            }\n            break\n          default:\n            break\n        }\n      })\n    })\n    \n    try {\n      observer.observe({ entryTypes })\n    } catch (error) {\n      console.warn('Failed to observe performance entries:', error)\n    }\n    \n    return () => {\n      observer.disconnect()\n    }\n  }, [entryTypes, updatePerformanceMetrics])\n}\n\n// Hook for Core Web Vitals monitoring\nexport const useCoreWebVitals = () => {\n  const { updatePerformanceMetrics } = usePerformanceActions()\n  \n  useEffect(() => {\n    // LCP (Largest Contentful Paint)\n    const lcpObserver = new PerformanceObserver((entryList) => {\n      const entries = entryList.getEntries()\n      const lastEntry = entries[entries.length - 1]\n      updatePerformanceMetrics({ lcp: lastEntry.startTime })\n    })\n    \n    // FID (First Input Delay)\n    const fidObserver = new PerformanceObserver((entryList) => {\n      const entries = entryList.getEntries()\n      entries.forEach((entry) => {\n        const fid = entry.processingStart - entry.startTime\n        updatePerformanceMetrics({ fid })\n      })\n    })\n    \n    // CLS (Cumulative Layout Shift)\n    let clsValue = 0\n    const clsObserver = new PerformanceObserver((entryList) => {\n      const entries = entryList.getEntries()\n      entries.forEach((entry) => {\n        if (!entry.hadRecentInput) {\n          clsValue += entry.value\n          updatePerformanceMetrics({ cls: clsValue })\n        }\n      })\n    })\n    \n    try {\n      lcpObserver.observe({ entryTypes: ['largest-contentful-paint'] })\n      fidObserver.observe({ entryTypes: ['first-input'] })\n      clsObserver.observe({ entryTypes: ['layout-shift'] })\n    } catch (error) {\n      console.warn('Core Web Vitals observation failed:', error)\n    }\n    \n    return () => {\n      lcpObserver.disconnect()\n      fidObserver.disconnect()\n      clsObserver.disconnect()\n    }\n  }, [updatePerformanceMetrics])\n}\n\n// Bundle size and memory monitoring\nexport const useResourceMonitoring = () => {\n  const { updatePerformanceMetrics } = usePerformanceActions()\n  const { addNotification } = useAppActions()\n  \n  useEffect(() => {\n    // Memory monitoring\n    const monitorMemory = () => {\n      if ('memory' in performance) {\n        const memoryInfo = performance.memory\n        updatePerformanceMetrics({\n          memoryUsed: memoryInfo.usedJSHeapSize,\n          memoryTotal: memoryInfo.totalJSHeapSize,\n          memoryLimit: memoryInfo.jsHeapSizeLimit\n        })\n        \n        // Alert on high memory usage\n        const memoryUsagePercent = (memoryInfo.usedJSHeapSize / memoryInfo.jsHeapSizeLimit) * 100\n        if (memoryUsagePercent > 80) {\n          addNotification({\n            type: 'warning',\n            title: 'High Memory Usage',\n            message: `Memory usage is at ${memoryUsagePercent.toFixed(1)}%`,\n            duration: 5000\n          })\n        }\n      }\n    }\n    \n    // Resource timing monitoring\n    const monitorResources = () => {\n      if ('PerformanceObserver' in window) {\n        const resourceObserver = new PerformanceObserver((list) => {\n          const entries = list.getEntries()\n          let totalTransferSize = 0\n          \n          entries.forEach((entry) => {\n            if (entry.transferSize) {\n              totalTransferSize += entry.transferSize\n            }\n          })\n          \n          if (totalTransferSize > 0) {\n            updatePerformanceMetrics({\n              resourceTransferSize: totalTransferSize\n            })\n          }\n        })\n        \n        try {\n          resourceObserver.observe({ entryTypes: ['resource'] })\n        } catch (error) {\n          console.warn('Resource monitoring failed:', error)\n        }\n        \n        return () => resourceObserver.disconnect()\n      }\n    }\n    \n    // Initial monitoring\n    monitorMemory()\n    const resourceCleanup = monitorResources()\n    \n    // Periodic memory monitoring\n    const memoryInterval = setInterval(monitorMemory, 30000) // Every 30 seconds\n    \n    return () => {\n      clearInterval(memoryInterval)\n      if (resourceCleanup) resourceCleanup()\n    }\n  }, [updatePerformanceMetrics, addNotification])\n}"