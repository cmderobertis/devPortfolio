/**\n * Global Error Boundary - Comprehensive error handling system\n * Features: Recovery mechanisms, error reporting, user feedback, hierarchical structure\n */\n\nimport React, { Component, createContext, useContext } from 'react'\nimport { useAppStore, useAppActions } from '../../store'\n\n// Error context for sharing error state\nconst ErrorContext = createContext({\n  errors: [],\n  hasError: false,\n  retry: () => {},\n  clearError: () => {},\n  reportError: () => {}\n})\n\nexport const useErrorHandler = () => {\n  const context = useContext(ErrorContext)\n  if (!context) {\n    throw new Error('useErrorHandler must be used within ErrorProvider')\n  }\n  return context\n}\n\n// Enhanced error boundary with recovery mechanisms\nexport class GlobalErrorBoundary extends Component {\n  constructor(props) {\n    super(props)\n    \n    this.state = {\n      hasError: false,\n      errors: [],\n      errorInfo: null,\n      retryCount: 0,\n      lastErrorTime: null\n    }\n    \n    // Bind methods\n    this.handleRetry = this.handleRetry.bind(this)\n    this.clearError = this.clearError.bind(this)\n    this.reportError = this.reportError.bind(this)\n  }\n  \n  static getDerivedStateFromError(error) {\n    // Update state to render error UI\n    return {\n      hasError: true,\n      lastErrorTime: Date.now()\n    }\n  }\n  \n  componentDidCatch(error, errorInfo) {\n    const errorEntry = {\n      id: `error_${Date.now()}`,\n      error,\n      errorInfo,\n      timestamp: new Date().toISOString(),\n      userAgent: navigator.userAgent,\n      url: window.location.href,\n      userId: null, // Would be populated if user is logged in\n      severity: this.categorizeError(error)\n    }\n    \n    this.setState(prevState => ({\n      errors: [...prevState.errors, errorEntry],\n      errorInfo: errorInfo\n    }))\n    \n    // Report error to store and external services\n    this.reportError(errorEntry)\n    \n    // Log error for development\n    if (process.env.NODE_ENV === 'development') {\n      console.group('üö® Error Boundary Caught Error')\n      console.error('Error:', error)\n      console.error('Error Info:', errorInfo)\n      console.error('Component Stack:', errorInfo.componentStack)\n      console.groupEnd()\n    }\n  }\n  \n  categorizeError(error) {\n    // Categorize errors by type and severity\n    if (error.name === 'ChunkLoadError' || error.message?.includes('Loading chunk')) {\n      return 'chunk-load'\n    }\n    if (error.name === 'TypeError' && error.message?.includes('Cannot read property')) {\n      return 'null-reference'\n    }\n    if (error.name === 'ReferenceError') {\n      return 'undefined-reference'\n    }\n    if (error.message?.includes('Network Error') || error.message?.includes('fetch')) {\n      return 'network'\n    }\n    return 'unknown'\n  }\n  \n  handleRetry() {\n    const now = Date.now()\n    const timeSinceLastError = now - (this.state.lastErrorTime || 0)\n    \n    // Prevent rapid retry attempts\n    if (timeSinceLastError < 2000) {\n      return\n    }\n    \n    this.setState(prevState => ({\n      hasError: false,\n      retryCount: prevState.retryCount + 1,\n      errorInfo: null,\n      lastErrorTime: now\n    }))\n    \n    // Add retry notification\n    const store = useAppStore.getState()\n    store.addNotification({\n      type: 'info',\n      title: 'Retrying...',\n      message: 'Attempting to recover from error',\n      duration: 2000\n    })\n  }\n  \n  clearError() {\n    this.setState({\n      hasError: false,\n      errors: [],\n      errorInfo: null,\n      retryCount: 0,\n      lastErrorTime: null\n    })\n  }\n  \n  reportError(errorEntry) {\n    try {\n      // Report to store\n      const store = useAppStore.getState()\n      store.setError(errorEntry.error, 'errorBoundary')\n      \n      // In production, report to error tracking service\n      if (process.env.NODE_ENV === 'production') {\n        // Example: Sentry, LogRocket, Bugsnag, etc.\n        // window.errorReporter?.captureException(errorEntry.error, {\n        //   extra: errorEntry\n        // })\n      }\n    } catch (reportingError) {\n      console.error('Failed to report error:', reportingError)\n    }\n  }\n  \n  getRecoveryStrategy(errorType) {\n    switch (errorType) {\n      case 'chunk-load':\n        return {\n          canRecover: true,\n          suggestion: 'Try refreshing the page to reload the application',\n          action: () => window.location.reload()\n        }\n      case 'network':\n        return {\n          canRecover: true,\n          suggestion: 'Check your internet connection and try again',\n          action: this.handleRetry\n        }\n      case 'null-reference':\n      case 'undefined-reference':\n        return {\n          canRecover: true,\n          suggestion: 'This may be a temporary issue. Try refreshing the page',\n          action: this.handleRetry\n        }\n      default:\n        return {\n          canRecover: false,\n          suggestion: 'Please refresh the page or contact support if the problem persists',\n          action: () => window.location.reload()\n        }\n    }\n  }\n  \n  render() {\n    if (this.state.hasError) {\n      const lastError = this.state.errors[this.state.errors.length - 1]\n      const errorType = lastError ? this.categorizeError(lastError.error) : 'unknown'\n      const recovery = this.getRecoveryStrategy(errorType)\n      \n      return (\n        <ErrorFallback\n          error={lastError}\n          errorType={errorType}\n          recovery={recovery}\n          retryCount={this.state.retryCount}\n          onRetry={this.handleRetry}\n          onClear={this.clearError}\n          onReport={() => this.reportError(lastError)}\n        />\n      )\n    }\n    \n    // Provide error context to children\n    const contextValue = {\n      errors: this.state.errors,\n      hasError: this.state.hasError,\n      retry: this.handleRetry,\n      clearError: this.clearError,\n      reportError: this.reportError\n    }\n    \n    return (\n      <ErrorContext.Provider value={contextValue}>\n        {this.props.children}\n      </ErrorContext.Provider>\n    )\n  }\n}\n\n// Error fallback UI component\nconst ErrorFallback = ({ \n  error, \n  errorType, \n  recovery, \n  retryCount, \n  onRetry, \n  onClear, \n  onReport \n}) => {\n  const handleKeyDown = (event, action) => {\n    if (event.key === 'Enter' || event.key === ' ') {\n      event.preventDefault()\n      action()\n    }\n  }\n  \n  return (\n    <div \n      className=\"error-boundary-fallback\" \n      role=\"alert\" \n      aria-live=\"assertive\"\n      style={{\n        padding: '2rem',\n        margin: '1rem',\n        border: '2px solid var(--md-sys-color-error)',\n        borderRadius: '8px',\n        backgroundColor: 'var(--md-sys-color-error-container)',\n        color: 'var(--md-sys-color-on-error-container)',\n        textAlign: 'center',\n        maxWidth: '600px',\n        marginLeft: 'auto',\n        marginRight: 'auto'\n      }}\n    >\n      <div className=\"error-icon\" style={{ fontSize: '3rem', marginBottom: '1rem' }}>\n        ‚ö†Ô∏è\n      </div>\n      \n      <h2 style={{ \n        margin: '0 0 1rem 0', \n        color: 'var(--md-sys-color-error)',\n        fontSize: '1.5rem'\n      }}>\n        Something went wrong\n      </h2>\n      \n      <div className=\"error-details\" style={{ marginBottom: '1.5rem' }}>\n        <p style={{ margin: '0 0 0.5rem 0' }}>\n          {recovery.suggestion}\n        </p>\n        \n        {process.env.NODE_ENV === 'development' && error && (\n          <details style={{ \n            marginTop: '1rem', \n            textAlign: 'left',\n            backgroundColor: 'var(--md-sys-color-surface-variant)',\n            padding: '1rem',\n            borderRadius: '4px'\n          }}>\n            <summary style={{ cursor: 'pointer', fontWeight: 'bold' }}>\n              Error Details (Development)\n            </summary>\n            <pre style={{ \n              fontSize: '0.8rem', \n              overflow: 'auto', \n              marginTop: '0.5rem',\n              whiteSpace: 'pre-wrap'\n            }}>\n              <strong>Error:</strong> {error.error?.message}\n              {error.error?.stack && (\n                <>\n                  <br /><br />\n                  <strong>Stack:</strong><br />\n                  {error.error.stack}\n                </>\n              )}\n            </pre>\n          </details>\n        )}\n        \n        {retryCount > 0 && (\n          <p style={{ \n            fontSize: '0.9rem', \n            opacity: 0.8,\n            marginTop: '1rem'\n          }}>\n            Retry attempt: {retryCount}\n          </p>\n        )}\n      </div>\n      \n      <div className=\"error-actions\" style={{ \n        display: 'flex', \n        gap: '1rem', \n        justifyContent: 'center',\n        flexWrap: 'wrap'\n      }}>\n        {recovery.canRecover && (\n          <button\n            onClick={recovery.action}\n            onKeyDown={(e) => handleKeyDown(e, recovery.action)}\n            style={{\n              padding: '0.75rem 1.5rem',\n              backgroundColor: 'var(--md-sys-color-primary)',\n              color: 'var(--md-sys-color-on-primary)',\n              border: 'none',\n              borderRadius: '24px',\n              cursor: 'pointer',\n              fontSize: '0.9rem',\n              fontWeight: '500'\n            }}\n          >\n            {errorType === 'chunk-load' ? 'Refresh Page' : 'Try Again'}\n          </button>\n        )}\n        \n        <button\n          onClick={onClear}\n          onKeyDown={(e) => handleKeyDown(e, onClear)}\n          style={{\n            padding: '0.75rem 1.5rem',\n            backgroundColor: 'transparent',\n            color: 'var(--md-sys-color-primary)',\n            border: '1px solid var(--md-sys-color-outline)',\n            borderRadius: '24px',\n            cursor: 'pointer',\n            fontSize: '0.9rem',\n            fontWeight: '500'\n          }}\n        >\n          Dismiss\n        </button>\n      </div>\n      \n      <p style={{ \n        fontSize: '0.8rem', \n        marginTop: '1.5rem', \n        opacity: 0.8 \n      }}>\n        If this problem persists, please refresh the page or contact support.\n      </p>\n    </div>\n  )\n}\n\n// Specialized error boundaries for different contexts\nexport class ChunkLoadErrorBoundary extends GlobalErrorBoundary {\n  componentDidCatch(error, errorInfo) {\n    if (error.name === 'ChunkLoadError' || error.message?.includes('Loading chunk')) {\n      // Handle chunk loading errors specifically\n      window.location.reload()\n      return\n    }\n    super.componentDidCatch(error, errorInfo)\n  }\n}\n\nexport class NetworkErrorBoundary extends GlobalErrorBoundary {\n  componentDidCatch(error, errorInfo) {\n    if (error.message?.includes('Network Error') || error.message?.includes('fetch')) {\n      // Handle network errors with retry logic\n      setTimeout(() => {\n        this.handleRetry()\n      }, 3000)\n      return\n    }\n    super.componentDidCatch(error, errorInfo)\n  }\n}\n\n// HOC for wrapping components with error boundaries\nexport const withErrorBoundary = (WrappedComponent, ErrorBoundaryComponent = GlobalErrorBoundary) => {\n  const WithErrorBoundaryComponent = (props) => {\n    return (\n      <ErrorBoundaryComponent>\n        <WrappedComponent {...props} />\n      </ErrorBoundaryComponent>\n    )\n  }\n  \n  WithErrorBoundaryComponent.displayName = `withErrorBoundary(${WrappedComponent.displayName || WrappedComponent.name})`\n  \n  return WithErrorBoundaryComponent\n}\n\n// Hook for manual error reporting\nexport const useErrorReporter = () => {\n  const { reportError } = useErrorHandler()\n  const { setError } = useAppActions()\n  \n  const reportManualError = (error, context = 'manual') => {\n    const errorEntry = {\n      id: `manual_error_${Date.now()}`,\n      error,\n      context,\n      timestamp: new Date().toISOString(),\n      userAgent: navigator.userAgent,\n      url: window.location.href\n    }\n    \n    reportError(errorEntry)\n    setError(error, context)\n  }\n  \n  return { reportError: reportManualError }\n}"