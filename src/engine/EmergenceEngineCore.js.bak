// src/engine/EmergenceEngineCore.js
import { createAgentPool, createVector3Pool } from '../utils/ObjectPool.js';

// Memory optimization pools
const agentPool = createAgentPool(200);
const vectorPool = createVector3Pool(50);
const neighborCache = new Map();

// Cleanup pools periodically
setInterval(() => {
  if (neighborCache.size > 50) {
    neighborCache.clear();
  }
}, 15000);

// Initialize agents based on pattern
export const initializeAgents = (pattern, canvas, rules, agentCountParams) => {
  if (pattern === 'cellular') {
    return [];
  }

  if (!canvas) return [];

  const width = canvas.width;
  const height = canvas.height;
  // Use agentCountParams for flexibility with reduced counts for performance
  const agentCount = Math.min(agentCountParams[pattern] || (
    pattern === 'neurons' ? 40 : pattern === 'economy' ? 30 : 60
  ), 100); // Cap at 100 agents for performance

  const agents = [];
  // Use object pool for better memory management
  for (let i = 0; i < agentCount; i++) {
    const agent = agentPool.acquire();
    agent.id = i;
    agent.x = Math.random() * width;
    agent.y = Math.random() * height;
    agent.vx = (Math.random() - 0.5) * 2;
    agent.vy = (Math.random() - 0.5) * 2;
    agent.energy = Math.random() * 100 + 50;
    agent.connections = [];
    agent.role = pattern === 'economy' ? ['producer', 'consumer', 'trader'][i % 3] : 'agent';
    agent.activation = 0;
    agent.alive = true;
    agents.push(agent);
  }
  return agents;
};

// Core emergence simulation
export const updateAgents = (currentAgents, canvas, rules, selectedPattern) => {
  if (!canvas || !currentAgents.length) return currentAgents;

  const width = canvas.width;
  const height = canvas.height;
  
  // Optimize neighbor calculations with caching
  const neighborRadius = 50;
  const radiusSquared = neighborRadius * neighborRadius;

  return currentAgents.map(agent => {
    let newVx = agent.vx;
    let newVy = agent.vy;
    let newEnergy = agent.energy;
    let newActivation = agent.activation * 0.9;

    // Optimized neighbor finding with squared distance
    const neighbors = [];
    for (let i = 0; i < currentAgents.length; i++) {
      const other = currentAgents[i];
      if (other.id !== agent.id) {
        const dx = other.x - agent.x;
        const dy = other.y - agent.y;
        const distSquared = dx * dx + dy * dy;
        if (distSquared < radiusSquared) {
          neighbors.push(other);
        }
      }
    }

    if (selectedPattern === 'flocking') {
      if (neighbors.length > 0) {
        const avgX = neighbors.reduce((sum, n) => sum + n.x, 0) / neighbors.length;
        const avgY = neighbors.reduce((sum, n) => sum + n.y, 0) / neighbors.length;
        newVx += (avgX - agent.x) * rules.cohesion * 0.001;
        newVy += (avgY - agent.y) * rules.cohesion * 0.001;

        neighbors.forEach(neighbor => {
          const dist = Math.hypot(neighbor.x - agent.x, neighbor.y - agent.y);
          if (dist < 25) { // Separation distance
            newVx -= (neighbor.x - agent.x) * rules.separation * 0.01 / dist;
            newVy -= (neighbor.y - agent.y) * rules.separation * 0.01 / dist;
          }
        });

        const avgVx = neighbors.reduce((sum, n) => sum + n.vx, 0) / neighbors.length;
        const avgVy = neighbors.reduce((sum, n) => sum + n.vy, 0) / neighbors.length;
        newVx += (avgVx - agent.vx) * rules.alignment * 0.1;
        newVy += (avgVy - agent.vy) * rules.alignment * 0.1;
      }
    } else if (selectedPattern === 'neurons') {
      const stimulation = neighbors.reduce((sum, n) => sum + n.activation, 0);
      if (stimulation > 30) { // Stimulation threshold
        newActivation = 100; // Activation level
        newEnergy -= 2; // Energy cost for firing
      }
      newVx *= 0.95; // Velocity decay
      newVy *= 0.95;
    } else if (selectedPattern === 'economy') {
      neighbors.forEach(neighbor => {
        if (agent.role === 'producer' && neighbor.role === 'consumer') {
          const trade = Math.min(agent.energy * 0.1, neighbor.energy * 0.05); // Trade amount
          newEnergy += trade;
          // neighbor.energy -= trade; // This would require modifying neighbor directly, tricky in map
        } else if (agent.role === 'trader') {
          newEnergy += neighbors.length * 0.5; // Trader bonus
        }
      });
      newEnergy = Math.max(10, Math.min(200, newEnergy)); // Energy bounds
    }

    newVx += (Math.random() - 0.5) * rules.randomness;
    newVy += (Math.random() - 0.5) * rules.randomness;

    const speed = Math.hypot(newVx, newVy);
    if (speed > rules.speed) {
      newVx = (newVx / speed) * rules.speed;
      newVy = (newVy / speed) * rules.speed;
    }

    let newX = agent.x + newVx;
    let newY = agent.y + newVy;

    // Boundary conditions (wrapping)
    if (newX < 0) newX = width;
    if (newX > width) newX = 0;
    if (newY < 0) newY = height;
    if (newY > height) newY = 0;

    return {
      ...agent,
      x: newX,
      y: newY,
      vx: newVx,
      vy: newVy,
      energy: newEnergy,
      activation: newActivation
    };
  });
};
