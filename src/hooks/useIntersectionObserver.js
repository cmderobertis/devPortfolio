/**\n * useIntersectionObserver Hook - Performance-optimized visibility detection\n * Features: Lazy loading, infinite scroll, analytics tracking, concurrent-safe updates\n */\n\nimport { useState, useEffect, useRef, useCallback, useMemo } from 'react'\nimport { useConcurrent } from '../components/concurrent/ConcurrentRoot'\nimport { usePerformanceActions } from '../store'\n\n// Main intersection observer hook\nexport const useIntersectionObserver = (options = {}) => {\n  const {\n    threshold = 0,\n    root = null,\n    rootMargin = '0px',\n    freezeOnceVisible = false,\n    triggerOnce = false,\n    concurrent = true,\n    trackPerformance = false\n  } = options\n\n  const [isIntersecting, setIsIntersecting] = useState(false)\n  const [entry, setEntry] = useState(null)\n  const elementRef = useRef(null)\n  const observerRef = useRef(null)\n  const frozenRef = useRef(false)\n\n  // Concurrent features\n  const { startTransition } = concurrent ? useConcurrent() : { startTransition: (cb) => cb() }\n  const { recordTiming } = trackPerformance ? usePerformanceActions() : { recordTiming: () => {} }\n\n  // Observer configuration\n  const observerConfig = useMemo(() => ({\n    threshold,\n    root,\n    rootMargin\n  }), [threshold, root, rootMargin])\n\n  // Update intersection state\n  const updateIntersection = useCallback((observerEntry) => {\n    const isCurrentlyIntersecting = observerEntry.isIntersecting\n    \n    // Skip updates if frozen\n    if (freezeOnceVisible && frozenRef.current) {\n      return\n    }\n\n    const updateState = () => {\n      setIsIntersecting(isCurrentlyIntersecting)\n      setEntry(observerEntry)\n      \n      // Freeze state if configured\n      if (freezeOnceVisible && isCurrentlyIntersecting) {\n        frozenRef.current = true\n      }\n    }\n\n    if (concurrent) {\n      startTransition(updateState)\n    } else {\n      updateState()\n    }\n\n    // Record performance timing\n    if (trackPerformance) {\n      recordTiming('intersection-observer', observerEntry.time, {\n        isIntersecting: isCurrentlyIntersecting,\n        intersectionRatio: observerEntry.intersectionRatio\n      })\n    }\n\n    // Disconnect after first trigger if configured\n    if (triggerOnce && isCurrentlyIntersecting && observerRef.current) {\n      observerRef.current.disconnect()\n    }\n  }, [freezeOnceVisible, triggerOnce, concurrent, startTransition, trackPerformance, recordTiming])\n\n  // Set up observer\n  const setElement = useCallback((element) => {\n    if (elementRef.current === element) return\n    \n    // Disconnect previous observer\n    if (observerRef.current) {\n      observerRef.current.disconnect()\n    }\n\n    elementRef.current = element\n\n    if (element && !frozenRef.current) {\n      observerRef.current = new IntersectionObserver(\n        ([entry]) => updateIntersection(entry),\n        observerConfig\n      )\n      observerRef.current.observe(element)\n    }\n  }, [observerConfig, updateIntersection])\n\n  // Cleanup\n  useEffect(() => {\n    return () => {\n      if (observerRef.current) {\n        observerRef.current.disconnect()\n      }\n    }\n  }, [])\n\n  // Reset function\n  const reset = useCallback(() => {\n    frozenRef.current = false\n    startTransition(() => {\n      setIsIntersecting(false)\n      setEntry(null)\n    })\n    \n    // Re-observe if element exists\n    if (elementRef.current) {\n      setElement(elementRef.current)\n    }\n  }, [setElement, startTransition])\n\n  return {\n    ref: setElement,\n    isIntersecting,\n    entry,\n    reset\n  }\n}\n\n// Hook for lazy loading images\nexport const useLazyImage = (src, options = {}) => {\n  const {\n    placeholder = null,\n    threshold = 0.1,\n    rootMargin = '50px',\n    onLoad = null,\n    onError = null,\n    ...observerOptions\n  } = options\n\n  const [imageSrc, setImageSrc] = useState(placeholder)\n  const [imageStatus, setImageStatus] = useState('idle') // idle, loading, loaded, error\n  \n  const { ref, isIntersecting } = useIntersectionObserver({\n    threshold,\n    rootMargin,\n    triggerOnce: true,\n    ...observerOptions\n  })\n\n  // Load image when visible\n  useEffect(() => {\n    if (isIntersecting && src && imageStatus === 'idle') {\n      setImageStatus('loading')\n      \n      const img = new Image()\n      \n      img.onload = () => {\n        setImageSrc(src)\n        setImageStatus('loaded')\n        if (onLoad) onLoad()\n      }\n      \n      img.onerror = () => {\n        setImageStatus('error')\n        if (onError) onError()\n      }\n      \n      img.src = src\n    }\n  }, [isIntersecting, src, imageStatus, onLoad, onError])\n\n  return {\n    ref,\n    src: imageSrc,\n    status: imageStatus,\n    isLoading: imageStatus === 'loading',\n    isLoaded: imageStatus === 'loaded',\n    isError: imageStatus === 'error'\n  }\n}\n\n// Hook for infinite scroll\nexport const useInfiniteScroll = (callback, options = {}) => {\n  const {\n    threshold = 1,\n    rootMargin = '100px',\n    enabled = true,\n    hasMore = true,\n    ...observerOptions\n  } = options\n\n  const [isLoading, setIsLoading] = useState(false)\n  const callbackRef = useRef(callback)\n  \n  // Update callback ref\n  useEffect(() => {\n    callbackRef.current = callback\n  }, [callback])\n\n  const { ref, isIntersecting } = useIntersectionObserver({\n    threshold,\n    rootMargin,\n    ...observerOptions\n  })\n\n  // Trigger callback when intersecting\n  useEffect(() => {\n    if (isIntersecting && enabled && hasMore && !isLoading) {\n      setIsLoading(true)\n      \n      const result = callbackRef.current()\n      \n      // Handle both sync and async callbacks\n      Promise.resolve(result)\n        .then(() => setIsLoading(false))\n        .catch(() => setIsLoading(false))\n    }\n  }, [isIntersecting, enabled, hasMore, isLoading])\n\n  return {\n    ref,\n    isLoading\n  }\n}\n\n// Hook for tracking element visibility (analytics)\nexport const useVisibilityTracking = (options = {}) => {\n  const {\n    threshold = 0.5,\n    minVisibleTime = 1000, // Minimum time visible to count as viewed\n    onVisible = null,\n    onHidden = null,\n    trackingData = {},\n    ...observerOptions\n  } = options\n\n  const [visibilityStats, setVisibilityStats] = useState({\n    isVisible: false,\n    totalVisibleTime: 0,\n    viewCount: 0,\n    lastVisibleTime: null\n  })\n  \n  const visibilityStartRef = useRef(null)\n  const minTimeTimeoutRef = useRef(null)\n\n  const { ref, isIntersecting } = useIntersectionObserver({\n    threshold,\n    ...observerOptions\n  })\n\n  // Track visibility changes\n  useEffect(() => {\n    if (isIntersecting) {\n      // Element became visible\n      visibilityStartRef.current = Date.now()\n      \n      setVisibilityStats(prev => ({\n        ...prev,\n        isVisible: true,\n        lastVisibleTime: visibilityStartRef.current\n      }))\n\n      // Set minimum visible time tracker\n      if (minVisibleTime > 0) {\n        minTimeTimeoutRef.current = setTimeout(() => {\n          if (onVisible) {\n            onVisible({\n              ...trackingData,\n              visibleTime: Date.now() - visibilityStartRef.current\n            })\n          }\n        }, minVisibleTime)\n      } else if (onVisible) {\n        onVisible(trackingData)\n      }\n    } else {\n      // Element became hidden\n      if (visibilityStartRef.current) {\n        const visibleDuration = Date.now() - visibilityStartRef.current\n        \n        setVisibilityStats(prev => ({\n          ...prev,\n          isVisible: false,\n          totalVisibleTime: prev.totalVisibleTime + visibleDuration,\n          viewCount: prev.viewCount + (visibleDuration >= minVisibleTime ? 1 : 0)\n        }))\n        \n        if (onHidden) {\n          onHidden({\n            ...trackingData,\n            visibleTime: visibleDuration,\n            qualifiedView: visibleDuration >= minVisibleTime\n          })\n        }\n      }\n      \n      // Clear minimum time tracker\n      if (minTimeTimeoutRef.current) {\n        clearTimeout(minTimeTimeoutRef.current)\n        minTimeTimeoutRef.current = null\n      }\n      \n      visibilityStartRef.current = null\n    }\n\n    // Cleanup\n    return () => {\n      if (minTimeTimeoutRef.current) {\n        clearTimeout(minTimeTimeoutRef.current)\n      }\n    }\n  }, [isIntersecting, minVisibleTime, onVisible, onHidden, trackingData])\n\n  return {\n    ref,\n    ...visibilityStats\n  }\n}\n\n// Hook for progressive loading of content sections\nexport const useProgressiveLoader = (items, options = {}) => {\n  const {\n    threshold = 0.1,\n    rootMargin = '200px',\n    batchSize = 5,\n    ...observerOptions\n  } = options\n\n  const [visibleItems, setVisibleItems] = useState([])\n  const [loadedBatches, setLoadedBatches] = useState(0)\n  const observersRef = useRef(new Map())\n  \n  // Create observers for each batch\n  const createObserver = useCallback((batchIndex) => {\n    const observer = new IntersectionObserver(\n      ([entry]) => {\n        if (entry.isIntersecting) {\n          const startIndex = batchIndex * batchSize\n          const endIndex = Math.min(startIndex + batchSize, items.length)\n          const batchItems = items.slice(startIndex, endIndex)\n          \n          setVisibleItems(prev => [...prev, ...batchItems])\n          setLoadedBatches(prev => Math.max(prev, batchIndex + 1))\n          \n          // Disconnect this observer\n          observer.disconnect()\n          observersRef.current.delete(batchIndex)\n        }\n      },\n      {\n        threshold,\n        rootMargin,\n        ...observerOptions\n      }\n    )\n    \n    return observer\n  }, [items, batchSize, threshold, rootMargin, observerOptions])\n\n  // Set up observers for sentinel elements\n  const setSentinelRef = useCallback((element, batchIndex) => {\n    if (element && !observersRef.current.has(batchIndex)) {\n      const observer = createObserver(batchIndex)\n      observer.observe(element)\n      observersRef.current.set(batchIndex, observer)\n    }\n  }, [createObserver])\n\n  // Cleanup observers\n  useEffect(() => {\n    return () => {\n      observersRef.current.forEach(observer => observer.disconnect())\n      observersRef.current.clear()\n    }\n  }, [])\n\n  // Calculate total batches\n  const totalBatches = Math.ceil(items.length / batchSize)\n  \n  return {\n    visibleItems,\n    loadedBatches,\n    totalBatches,\n    setSentinelRef,\n    hasMore: loadedBatches < totalBatches\n  }\n}\n\n// Hook for element dimension tracking\nexport const useElementDimensions = () => {\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0 })\n  const elementRef = useRef(null)\n  const observerRef = useRef(null)\n\n  const setElement = useCallback((element) => {\n    if (elementRef.current === element) return\n    \n    // Disconnect previous observer\n    if (observerRef.current) {\n      observerRef.current.disconnect()\n    }\n\n    elementRef.current = element\n\n    if (element) {\n      // Use ResizeObserver if available, fallback to IntersectionObserver\n      if ('ResizeObserver' in window) {\n        observerRef.current = new ResizeObserver(([entry]) => {\n          const { width, height } = entry.contentRect\n          setDimensions({ width, height })\n        })\n        observerRef.current.observe(element)\n      } else {\n        // Fallback to IntersectionObserver with getBoundingClientRect\n        observerRef.current = new IntersectionObserver(([entry]) => {\n          const rect = entry.boundingClientRect\n          setDimensions({ width: rect.width, height: rect.height })\n        })\n        observerRef.current.observe(element)\n      }\n    }\n  }, [])\n\n  useEffect(() => {\n    return () => {\n      if (observerRef.current) {\n        observerRef.current.disconnect()\n      }\n    }\n  }, [])\n\n  return {\n    ref: setElement,\n    dimensions\n  }\n}"