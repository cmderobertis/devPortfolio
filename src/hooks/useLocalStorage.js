/**\n * useLocalStorage Hook - Enhanced local storage management with sync\n * Features: Cross-tab sync, type safety, concurrent-safe updates, error handling\n */\n\nimport { useState, useEffect, useCallback, useRef } from 'react'\nimport { useConcurrent } from '../components/concurrent/ConcurrentRoot'\nimport { useAppActions } from '../store'\n\n// Type serialization utilities\nconst serialize = (value) => {\n  try {\n    return JSON.stringify(value)\n  } catch (error) {\n    console.warn('Failed to serialize value for localStorage:', error)\n    return null\n  }\n}\n\nconst deserialize = (value) => {\n  if (value === null || value === undefined) return null\n  \n  try {\n    return JSON.parse(value)\n  } catch (error) {\n    // Return the raw value if it's not JSON\n    return value\n  }\n}\n\n// Main localStorage hook\nexport const useLocalStorage = (key, initialValue, options = {}) => {\n  const {\n    syncAcrossTabs = true,\n    serializer = { serialize, deserialize },\n    onError = null,\n    concurrent = true,\n    validator = null // Function to validate loaded values\n  } = options\n\n  // Refs for tracking\n  const keyRef = useRef(key)\n  const initialValueRef = useRef(initialValue)\n  const listenerRef = useRef(null)\n\n  // Concurrent features\n  const { startTransition } = concurrent ? useConcurrent() : { startTransition: (cb) => cb() }\n  const { addNotification } = useAppActions()\n\n  // Get initial value from localStorage\n  const getStoredValue = useCallback(() => {\n    try {\n      const item = localStorage.getItem(key)\n      \n      if (item === null) {\n        return initialValue\n      }\n\n      const parsed = serializer.deserialize(item)\n      \n      // Validate if validator is provided\n      if (validator && !validator(parsed)) {\n        console.warn(`Invalid value in localStorage for key \"${key}\":`, parsed)\n        return initialValue\n      }\n\n      return parsed\n    } catch (error) {\n      console.error(`Error reading localStorage key \"${key}\":`, error)\n      \n      if (onError) {\n        onError(error, 'read')\n      } else {\n        addNotification({\n          type: 'warning',\n          title: 'Storage Error',\n          message: `Failed to read from storage: ${key}`,\n          duration: 3000\n        })\n      }\n      \n      return initialValue\n    }\n  }, [key, initialValue, serializer, validator, onError, addNotification])\n\n  // State initialization\n  const [storedValue, setStoredValue] = useState(getStoredValue)\n  \n  // Set value function\n  const setValue = useCallback((value) => {\n    try {\n      // Allow function updates like useState\n      const valueToStore = value instanceof Function ? value(storedValue) : value\n      \n      // Update state\n      const updateState = () => {\n        setStoredValue(valueToStore)\n      }\n      \n      if (concurrent) {\n        startTransition(updateState)\n      } else {\n        updateState()\n      }\n      \n      // Update localStorage\n      if (valueToStore === undefined) {\n        localStorage.removeItem(key)\n      } else {\n        const serialized = serializer.serialize(valueToStore)\n        if (serialized !== null) {\n          localStorage.setItem(key, serialized)\n        }\n      }\n    } catch (error) {\n      console.error(`Error setting localStorage key \"${key}\":`, error)\n      \n      if (onError) {\n        onError(error, 'write')\n      } else {\n        addNotification({\n          type: 'error',\n          title: 'Storage Error',\n          message: `Failed to save to storage: ${key}`,\n          duration: 5000\n        })\n      }\n    }\n  }, [key, storedValue, serializer, onError, concurrent, startTransition, addNotification])\n\n  // Remove value function\n  const removeValue = useCallback(() => {\n    try {\n      localStorage.removeItem(key)\n      \n      const updateState = () => {\n        setStoredValue(initialValue)\n      }\n      \n      if (concurrent) {\n        startTransition(updateState)\n      } else {\n        updateState()\n      }\n    } catch (error) {\n      console.error(`Error removing localStorage key \"${key}\":`, error)\n      \n      if (onError) {\n        onError(error, 'remove')\n      }\n    }\n  }, [key, initialValue, onError, concurrent, startTransition])\n\n  // Sync across tabs\n  useEffect(() => {\n    if (!syncAcrossTabs) return\n\n    const handleStorageChange = (e) => {\n      if (e.key === key && e.newValue !== serializer.serialize(storedValue)) {\n        const newValue = e.newValue === null ? initialValue : serializer.deserialize(e.newValue)\n        \n        // Validate if validator is provided\n        if (validator && newValue !== initialValue && !validator(newValue)) {\n          console.warn(`Invalid synced value for key \"${key}\":`, newValue)\n          return\n        }\n        \n        const updateState = () => {\n          setStoredValue(newValue)\n        }\n        \n        if (concurrent) {\n          startTransition(updateState)\n        } else {\n          updateState()\n        }\n      }\n    }\n\n    window.addEventListener('storage', handleStorageChange)\n    listenerRef.current = handleStorageChange\n\n    return () => {\n      window.removeEventListener('storage', handleStorageChange)\n      listenerRef.current = null\n    }\n  }, [key, storedValue, initialValue, serializer, validator, syncAcrossTabs, concurrent, startTransition])\n\n  // Handle key changes\n  useEffect(() => {\n    if (keyRef.current !== key || initialValueRef.current !== initialValue) {\n      keyRef.current = key\n      initialValueRef.current = initialValue\n      \n      const newValue = getStoredValue()\n      const updateState = () => {\n        setStoredValue(newValue)\n      }\n      \n      if (concurrent) {\n        startTransition(updateState)\n      } else {\n        updateState()\n      }\n    }\n  }, [key, initialValue, getStoredValue, concurrent, startTransition])\n\n  return [storedValue, setValue, removeValue]\n}\n\n// Hook for storing objects with schema validation\nexport const useLocalStorageObject = (key, initialValue, schema = null) => {\n  const validator = useCallback((value) => {\n    if (!schema || typeof value !== 'object' || value === null) {\n      return !schema // If no schema, accept anything; if schema exists, reject non-objects\n    }\n    \n    // Simple schema validation (check required keys)\n    if (Array.isArray(schema)) {\n      return schema.every(requiredKey => requiredKey in value)\n    }\n    \n    // More complex schema validation could be added here\n    return true\n  }, [schema])\n\n  return useLocalStorage(key, initialValue, { validator })\n}\n\n// Hook for arrays with item validation\nexport const useLocalStorageArray = (key, initialValue = [], itemValidator = null) => {\n  const validator = useCallback((value) => {\n    if (!Array.isArray(value)) return false\n    \n    if (itemValidator) {\n      return value.every(item => itemValidator(item))\n    }\n    \n    return true\n  }, [itemValidator])\n\n  const [array, setArray, removeArray] = useLocalStorage(key, initialValue, { validator })\n\n  // Helper methods for array operations\n  const push = useCallback((item) => {\n    setArray(prev => [...prev, item])\n  }, [setArray])\n\n  const pop = useCallback(() => {\n    setArray(prev => {\n      const newArray = [...prev]\n      return newArray.slice(0, -1)\n    })\n  }, [setArray])\n\n  const removeAt = useCallback((index) => {\n    setArray(prev => {\n      const newArray = [...prev]\n      newArray.splice(index, 1)\n      return newArray\n    })\n  }, [setArray])\n\n  const updateAt = useCallback((index, newItem) => {\n    setArray(prev => {\n      const newArray = [...prev]\n      newArray[index] = newItem\n      return newArray\n    })\n  }, [setArray])\n\n  const clear = useCallback(() => {\n    setArray([])\n  }, [setArray])\n\n  return {\n    array,\n    setArray,\n    removeArray,\n    push,\n    pop,\n    removeAt,\n    updateAt,\n    clear,\n    length: array.length\n  }\n}\n\n// Hook for boolean flags with toggle functionality\nexport const useLocalStorageBoolean = (key, initialValue = false) => {\n  const [value, setValue, removeValue] = useLocalStorage(key, initialValue)\n\n  const toggle = useCallback(() => {\n    setValue(prev => !prev)\n  }, [setValue])\n\n  const setTrue = useCallback(() => setValue(true), [setValue])\n  const setFalse = useCallback(() => setValue(false), [setValue])\n\n  return {\n    value: Boolean(value),\n    setValue,\n    removeValue,\n    toggle,\n    setTrue,\n    setFalse\n  }\n}\n\n// Hook for managing preferences with defaults\nexport const usePreferences = (key = 'user-preferences', defaultPreferences = {}) => {\n  const [preferences, setPreferences, removePreferences] = useLocalStorageObject(\n    key, \n    defaultPreferences,\n    Object.keys(defaultPreferences) // Validate required keys\n  )\n\n  const updatePreference = useCallback((prefKey, value) => {\n    setPreferences(prev => ({\n      ...prev,\n      [prefKey]: value\n    }))\n  }, [setPreferences])\n\n  const resetPreference = useCallback((prefKey) => {\n    if (prefKey in defaultPreferences) {\n      updatePreference(prefKey, defaultPreferences[prefKey])\n    }\n  }, [updatePreference, defaultPreferences])\n\n  const resetAllPreferences = useCallback(() => {\n    setPreferences(defaultPreferences)\n  }, [setPreferences, defaultPreferences])\n\n  return {\n    preferences,\n    setPreferences,\n    updatePreference,\n    resetPreference,\n    resetAllPreferences,\n    removePreferences\n  }\n}\n\n// Hook for session-like storage with expiration\nexport const useSessionStorage = (key, initialValue, expirationMinutes = 60) => {\n  const serializer = {\n    serialize: (value) => {\n      const expirationTime = Date.now() + (expirationMinutes * 60 * 1000)\n      return JSON.stringify({ value, expirationTime })\n    },\n    deserialize: (value) => {\n      try {\n        const parsed = JSON.parse(value)\n        \n        if (parsed.expirationTime && Date.now() > parsed.expirationTime) {\n          // Expired, remove from storage\n          localStorage.removeItem(key)\n          return null\n        }\n        \n        return parsed.value\n      } catch {\n        return value\n      }\n    }\n  }\n\n  const validator = useCallback((value) => {\n    // Value is valid if it's not null or if it hasn't expired\n    return value !== null\n  }, [])\n\n  return useLocalStorage(key, initialValue, { serializer, validator })\n}\n\n// Utility function to get storage usage\nexport const useStorageInfo = () => {\n  const [storageInfo, setStorageInfo] = useState({\n    used: 0,\n    available: 0,\n    percentage: 0\n  })\n\n  const updateStorageInfo = useCallback(() => {\n    try {\n      let used = 0\n      for (let key in localStorage) {\n        if (localStorage.hasOwnProperty(key)) {\n          used += localStorage[key].length + key.length\n        }\n      }\n\n      // Estimate available storage (usually around 5-10MB)\n      const available = 5 * 1024 * 1024 // 5MB estimate\n      const percentage = (used / available) * 100\n\n      setStorageInfo({ used, available, percentage })\n    } catch (error) {\n      console.warn('Failed to calculate storage info:', error)\n    }\n  }, [])\n\n  useEffect(() => {\n    updateStorageInfo()\n    \n    // Update on storage events\n    const handleStorage = () => updateStorageInfo()\n    window.addEventListener('storage', handleStorage)\n    \n    return () => {\n      window.removeEventListener('storage', handleStorage)\n    }\n  }, [updateStorageInfo])\n\n  return { ...storageInfo, refresh: updateStorageInfo }\n}"